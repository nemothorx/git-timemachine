#!/bin/bash

# "github ls"

# This script gives a listing reminiscent of github (and similar) interfaces:
# filename ~ descripton of last commit against this file ~ date of commit
#
# It works by parsing the output of `git log` (once) and `git log <file>` (once
# for every file). It's not optimal but works reasonably well for moderate
# sized repos (but prob not good for linux kernel sort of thing!)
#

# TODO: investigate gitea, gitlab, etc for how they show summaries too

# Check if we're even in a git repo and tell us about it
git status 2>/dev/null
case $? in 
    128) 
        echo "* Not a git repo. Have directory listing from ls"
        echo ""
        # in a similarish order to github though
        ls -ohA --group-directories-first 
        exit
        # TODO: consider having custom output matching the rest of the style?
        ;;
esac

export IFS="	"   # tab only for IFS - for parsing sanity later

# setup some default variables for later compare
fnameprev=".non.null.string"    # musn't match a dir name, hence dotfile style
ttimenewest=1   # newer times will be bigger numbers
# setup some variables for pretty colour formatting too
white=$(tput setaf 7)
boldwhite=$(tput setaf 15)
teal=$(tput setaf 14)
green=$(tput setaf 10)
yellow=$(tput setaf 11)
reset=$(tput sgr0)
greyback=$(tput setab 8)


do_getfileinfo() {
    intype=$1
    infile=$2
    # note: there are TABs within this for the output
    subjecttime=$(git log -n 1 --format=format:'%s	%ar' $infile | head -n 1)
    echo "$intype	$infile	$subjecttime"
}


####################################################### main, basically

# first: summary line, github style

# TODO: should it be to HEAD? what if I'm in a different branch locally?

gitrepoinfo=$(git log --abbrev-commit --abbrev=10 --format=format:"%an	%h	%ar	%s" -n 1)
gri_authorname=$(echo "$gitrepoinfo" | cut -f 1)
gri_hash=$(echo "$gitrepoinfo" | cut -f 2)
gri_authorreltime=$(echo "$gitrepoinfo" | cut -f 3)
gri_summary=$(echo "$gitrepoinfo" | cut -f 4)
gri_commitcount=$(git rev-list HEAD --count)
    # this is more accurate than the old method of counting entries in `git log`
    # ...this way gives a smaller number but accurate to github

printf "$greyback $white%-12s $boldwhite%-28s $greenâœ” $yellow%7s %14s $white%3s commits $reset\n" ${gri_authorname:0:12} ${gri_summary:0:28} ${gri_hash:0:7} ${gri_authorreltime:0:14} $gri_commitcount

# detect if we're in a subdirectory and give a directory-specific status
# (this is rquiv to the only one github gives)

dirdiff=$(realpath --relative-to=$(git rev-parse --show-toplevel) .)
if [ $dirdiff != "." ] ; then
    gitdirinfo=$(git log --abbrev-commit --abbrev=10 --format=format:"%an	%h	%ar	%s" -n 1 .)
    gdi_authorname=$(echo "$gitdirinfo" | cut -f 1)
    gdi_hash=$(echo "$gitdirinfo" | cut -f 2)
    gdi_authorreltime=$(echo "$gitdirinfo" | cut -f 3)
    gdi_summary=$(echo "$gitdirinfo" | cut -f 4)
    echo "  $greyback$dirdiff$reset"
    printf "  $greyback \`-> $white%-12s $boldwhite%-35s $greenâœ” $yellow%7s %14s $reset\n" ${gdi_authorname:0:12} ${gdi_summary:0:35} ${gdi_hash:0:7} ${gdi_authorreltime:0:14}
fi

# now give a line per directory/file found

while read ftype fname subject time ; do    # 
    # TODO: option to switch between emoji and ascii directory symbol
#    typ="ðŸ—Ž" ; [ -d "$fname" ] && typ="ðŸ–¿" # folder or file?
#    typ="-" ; [ -d "$fname" ] && typ="d" # folder or file?
    typ=$ftype
    [ $ftype == "f" ] && typ="-"
    # TODO: option to switch between relative and absolute time
    # TODO: detect if name/summary are truncated and append "â€¦"  
#   printf "%-3s %-20s %-36s %17s\n" $typ ${fname:0:20} ${summary:0:36} $(date -d @$ttime +"%F %T")
    printf "%-2s %-16s $teal%-45s $yellow%14s$reset\n" $typ ${fname:0:16} ${subject:0:45} ${time:0:14}
done < <(find . -mindepth 1 -maxdepth 1 -not -name '.git' -printf "%Y	%P\n" | sort | while read ft fn ; do
            do_getfileinfo $ft "${fn}" 2>/dev/null
        done) 


## TODO: 
# * would be neat to handle this way better than designed-for-80column
#   hardcoded printf. 
#   Instead we should calculate max string lengths for name and time, and then
#   truncate msg to suit and then offload formatting to `|column -t`?
# * Add feature to `touch` each file with it's newest time (and perhaps each
#   directory with the newest file-creation-time within), so as to bring the
#   filesystem idea of mtime in sync with git's idea. 
#   Thus common tools (ls/find) can find recent (or old) files by normal means 


