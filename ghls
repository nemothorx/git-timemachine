#!/bin/bash

# "github ls"

# This script gives a listing reminiscent of github (and similar) interfaces:
# filename ~ descripton of last commit against this file ~ date of commit
#
# It works by parsing the output of `git log` (once) and `git log <file>` (once
# for every file). It's not optimal but works reasonably well for moderate
# sized repos (but prob not good for linux kernel sort of thing!)
#

# TODO: investigate gitea, gitlab, etc for how they show summaries too

# Check if we're even in a git repo and tell us about it
git status 2>/dev/null
case $? in 
    128) 
        echo "* Not a git repo. Have directory listing from ls"
        echo ""
        # in a similarish order to github though
        ls -ohA --group-directories-first 
        exit
        # TODO: consider having custom output matching the rest of the style?
        ;;
esac

export IFS="	"   # tab only for IFS - for parsing sanity later

# setup some default variables for later compare
fnameprev=".non.null.string"    # musn't match a dir name, hence dotfile style
ttimenewest=1   # newer times will be bigger numbers
# setup some variables for pretty colour formatting too
white=$(tput setaf 7)
boldwhite=$(tput setaf 15)
teal=$(tput setaf 14)
green=$(tput setaf 10)
yellow=$(tput setaf 11)
reset=$(tput sgr0)
greyback=$(tput setab 8)


do_getfileinfo() {
    intype=$1
    infile=$2
    # note: there are TABs within this for the output
    subjecttime=$(git log -n 1 --format=format:'%s	%ar' $infile | head -n 1)
    echo "$intype	$infile	$subjecttime"
}


####################################################### main, basically

# first: summary line, github style

commitcount=$(git rev-list HEAD --count)

# note: I'm relying on `cat -n` being tab separated, to match above IFS ;)
gitrepoinfo=$(git log --abbrev-commit --abbrev=10 --format=format:"%an	%h	%ar	%s" -n 1)
authorname=$(echo "$gitrepoinfo" | cut -f 1)
githash=$(echo "$gitrepoinfo" | cut -f 2)
authorreltime=$(echo "$gitrepoinfo" | cut -f 3)
summary=$(echo "$gitrepoinfo" | cut -f 4)


    printf "$greyback $white%-12s $boldwhite%-28s $greenâœ” $yellow%7s %14s $white%3s commits $reset\n" ${authorname:0:12} ${summary:0:28} ${githash:0:7} ${authorreltime:0:14} $commitcount

# TODO: summaryline should be differnt when we're in a subdirectory

while read ftype fname subject time ; do    # 
    # TODO: option to switch between emoji and ascii directory symbol
#    typ="ðŸ—Ž" ; [ -d "$fname" ] && typ="ðŸ–¿" # folder or file?
#    typ="-" ; [ -d "$fname" ] && typ="d" # folder or file?
    typ=$ftype
    [ $ftype == "f" ] && typ="-"
    # TODO: option to switch between relative and absolute time
    # TODO: detect if name/summary are truncated and append "â€¦"  
#   printf "%-3s %-20s %-36s %17s\n" $typ ${fname:0:20} ${summary:0:36} $(date -d @$ttime +"%F %T")
    printf "%-2s %-16s $teal%-45s $yellow%14s$reset\n" $typ ${fname:0:16} ${subject:0:45} ${time:0:14}
done < <(find . -mindepth 1 -maxdepth 1 -not -name '.git' -printf "%Y	%P\n" | sort -V | while read ft fn ; do
            do_getfileinfo $ft "${fn}" 2>/dev/null
        done) 


## TODO: 
# * would be neat to handle this way better than designed-for-80column
#   hardcoded printf. 
#   Instead we should calculate max string lengths for name and time, and then
#   truncate msg to suit and then offload formatting to `|column -t`?
# * Add feature to `touch` each file with it's newest time (and perhaps each
#   directory with the newest file-creation-time within), so common `ls` and
#   `find` tools can find recent (or old) files by those normal means too


