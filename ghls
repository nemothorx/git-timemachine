#!/bin/bash

# "github ls"

# This script gives a listing reminiscent of github (and similar) interfaces:
# filename ~ descripton of last commit against this file ~ date of commit
#
# It works by parsing the output of `git log` (once) and `git log <file>` (once
# for every file). It's not optimal but works reasonably well for moderate
# sized repos (but prob not good for linux kernel sort of thing!)
#

# Check if we're even in a git repo and tell us about it
git status 2>/dev/null
case $? in 
    128) 
        echo "* Not a git repo. Have directory listing from ls"
        echo ""
        # in a similarish order to github though
        ls -ohA --group-directories-first 
        exit
        # TODO: consider having custom output matching the rest of the style?
        ;;
esac

export IFS="	"   # tab only for IFS - for parsing sanity later

# setup some default variables for later compare
fnameprev=".non.null.string"    # musn't match a dir name, hence dotfile style
ttimenewest=1   # newer times will be bigger numbers
# setup some variables for pretty colour formatting too
white=$(tput setaf 7)
boldwhite=$(tput setaf 15)
teal=$(tput setaf 14)
green=$(tput setaf 10)
yellow=$(tput setaf 11)
reset=$(tput sgr0)
greyback=$(tput setab 8)

declare -A titleline    # an associative array for the git repo summary line
declare -A dirline    # an associative array for the directory summary line
declare -A relatime     # an associative array of relative times for hashes

do_getfileinfo() {
    intype=$1
    infile=$2
    # note: there are TABs within this for the output
    subjecttime=$(git log -n 1 --format=format:'%s	%ar' $infile | head -n 1)
    echo "$intype	$infile	$subjecttime"
}


####################################################### main, basically

# first: summary line, github style

# note: I'm relying on `cat -n` being tab separated, to match above IFS ;)
while read num authorname githash authorreltime summary; do
    # summary is at the end in case it's nonexistent, which can happen
    if [ $num -eq 1 ] ; then
        titleline[an]=$authorname
        titleline[s]=$summary
        titleline[h]=$githash
        titleline[ar]=$authorreltime
    fi
    # populate a hash here with friendly relative times
    relatime[a$githash]="$authorreltime"
done < <(git log --abbrev-commit --abbrev=10 --format=format:"%an	%h	%ar	%s" --all | cat -n | sed -e 's/^\s*//g')

# and our loop finished with $num set to our count of commits. 
printf "$greyback $white%-12s $boldwhite%-28s $greenâœ” $yellow%7s %14s $white%3s commits $reset\n" ${titleline[an]:0:12} ${titleline[s]:0:28} ${titleline[h]:0:7} ${titleline[ar]:0:14} $num

# TODO: sanity check the status line behaviour when we're in a subdirectory got the git repo 
#   ...target = similar to github (what do gitea? gitlab? others? look like?)

while read ftype fname subject time ; do    # 
    # TODO: option to switch between emoji and ascii directory symbol
#    typ="ðŸ—Ž" ; [ -d "$fname" ] && typ="ðŸ–¿" # folder or file?
#    typ="-" ; [ -d "$fname" ] && typ="d" # folder or file?
    typ=$ftype
    [ $ftype == "f" ] && typ="-"
    # TODO: option to switch between relative and absolute time
    # TODO: detect if name/summary are truncated and append "â€¦"  
#   printf "%-3s %-20s %-36s %17s\n" $typ ${fname:0:20} ${summary:0:36} $(date -d @$ttime +"%F %T")
    printf "%-2s %-16s $teal%-45s $yellow%14s$reset\n" $typ ${fname:0:16} ${subject:0:45} ${time:0:14}
done < <(find . -mindepth 1 -maxdepth 1 -not -name '.git' -printf "%Y	%P\n" | sort -V | while read ft fn ; do
            do_getfileinfo $ft "${fn}" 2>/dev/null
        done) 


## TODO: 
# * would be neat to handle this way better than designed-for-80column
#   hardcoded printf. 
#   Instead we should calculate max string lengths for name and time, and then
#   truncate msg to suit and then offload formatting to `|column -t`?
# * Add feature to `touch` each file with it's newest time (and perhaps each
#   directory with the newest file-creation-time within), so common `ls` and
#   `find` tools can find recent (or old) files by those normal means too


